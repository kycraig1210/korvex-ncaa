<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>KORVEX — NCAAB Betting Intelligence</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.0/dist/chartjs-plugin-annotation.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=Manrope:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
/*  ═══════════════════════════════════════════════════════════════════════
    KORVEX TERMINAL — Precision Sports Analytics
    Aesthetic: "Bloomberg Terminal meets Mission Control"
    Dark, data-dense, phosphor-green accents, monospace numerics
    ═══════════════════════════════════════════════════════════════════════ */

*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}

:root{
  --void:#060710;
  --bg:#0a0b12;
  --s1:#0f1019;
  --s2:#141520;
  --s3:#191b28;
  --s-hover:#1c1e2d;
  --edge:#1a1d2c;
  --edge-hi:#272b3e;
  --edge-focus:#363c56;
  --ink:#e0e3ee;
  --ink2:#969ab2;
  --ink3:#6a6e84;
  --ink-mute:#484c62;
  --pos:#2dd4a0;
  --pos-dim:rgba(45,212,160,.1);
  --pos-glow:rgba(45,212,160,.22);
  --neg:#f4718a;
  --neg-dim:rgba(244,113,138,.1);
  --neg-glow:rgba(244,113,138,.22);
  --warn:#f5c542;
  --warn-dim:rgba(245,197,66,.1);
  --blue:#5b9cf5;
  --blue-dim:rgba(91,156,245,.1);
  --purple:#9b7ff0;
  --cyan:#22d3ee;
  --orange:#f09c5b;
  --r:10px
}

html{font-size:15px;-webkit-font-smoothing:antialiased}
body{
  font-family:'Manrope',sans-serif;background:var(--bg);color:var(--ink);
  min-height:100vh;overflow-x:hidden;
  background-image:
    radial-gradient(ellipse 55% 30% at 50% -8%,rgba(45,212,160,.025),transparent),
    radial-gradient(ellipse 45% 25% at 80% 105%,rgba(91,156,245,.02),transparent);
}

::-webkit-scrollbar{width:5px;height:5px}
::-webkit-scrollbar-track{background:var(--void)}
::-webkit-scrollbar-thumb{background:var(--edge-hi);border-radius:3px}

/* ── LOADING ───────────────────────────────────────────────────────── */
#loader{
  position:fixed;inset:0;z-index:9999;background:var(--bg);
  display:flex;flex-direction:column;align-items:center;justify-content:center;gap:1.4rem;
  transition:opacity .5s,visibility .5s;
}
#loader.done{opacity:0;visibility:hidden;pointer-events:none}
.ld-brand{
  font-family:'IBM Plex Mono',monospace;font-weight:600;font-size:1.3rem;
  letter-spacing:.18em;color:var(--pos);text-shadow:0 0 28px var(--pos-glow);
}
.ld-ring{
  width:28px;height:28px;border:2px solid var(--edge-hi);border-top-color:var(--pos);
  border-radius:50%;animation:spin .7s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}
.ld-msg{font-family:'IBM Plex Mono',monospace;font-size:.7rem;color:var(--ink3);letter-spacing:.05em}

/* ── ERROR ──────────────────────────────────────────────────────────── */
#errBox{
  display:none;margin:1rem 2rem 0;padding:.9rem 1.3rem;
  background:var(--neg-dim);border:1px solid rgba(244,113,138,.25);border-radius:var(--r);
  font-family:'IBM Plex Mono',monospace;font-size:.75rem;color:var(--neg);line-height:1.7;
}

/* ── HEADER ─────────────────────────────────────────────────────────── */
header{
  padding:1.4rem 2.2rem 1.1rem;border-bottom:1px solid var(--edge);
  display:flex;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:.8rem;
  background:linear-gradient(180deg,rgba(45,212,160,.012),transparent);
}
.hd-brand{
  font-family:'IBM Plex Mono',monospace;font-weight:600;font-size:1.25rem;
  letter-spacing:.16em;color:var(--pos);text-shadow:0 0 26px var(--pos-glow);
}
.hd-brand em{
  font-style:normal;color:var(--ink-mute);font-weight:300;font-size:.75rem;
  letter-spacing:.08em;margin-left:.6rem;
}
.hd-sub{font-size:.7rem;color:var(--ink3);font-family:'IBM Plex Mono',monospace;letter-spacing:.04em;margin-top:.15rem}
.hd-meta{font-family:'IBM Plex Mono',monospace;font-size:.67rem;color:var(--ink-mute);text-align:right;line-height:1.7}
.hd-meta b{color:var(--ink2)}
.live-dot{
  display:inline-flex;align-items:center;gap:5px;font-size:.6rem;color:var(--pos);
  font-weight:600;letter-spacing:.07em;text-transform:uppercase;
}
.live-dot::before{
  content:'';width:5px;height:5px;border-radius:50%;background:var(--pos);
  box-shadow:0 0 7px var(--pos-glow);animation:blink 2s ease infinite;
}
@keyframes blink{0%,100%{opacity:1}50%{opacity:.3}}

/* ── LAYOUT ─────────────────────────────────────────────────────────── */
.wrap{max-width:1500px;margin:0 auto;padding:1.3rem 2rem 3rem}

@keyframes rise{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}
.anim{opacity:0;animation:rise .4s ease forwards}

/* ── KPI CARDS ──────────────────────────────────────────────────────── */
.kpi-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(190px,1fr));gap:.8rem;margin-bottom:1.3rem}
.kpi{
  background:var(--s1);border:1px solid var(--edge);border-radius:var(--r);
  padding:1.05rem 1.2rem;position:relative;overflow:hidden;
  transition:border-color .2s,background .2s,transform .18s;
}
.kpi:hover{border-color:var(--edge-hi);background:var(--s-hover);transform:translateY(-1px)}
.kpi::after{content:'';position:absolute;top:0;left:0;right:0;height:2px;opacity:.45;transition:opacity .2s}
.kpi:hover::after{opacity:.8}
.kpi.t-pos::after{background:linear-gradient(90deg,transparent,var(--pos),transparent)}
.kpi.t-neg::after{background:linear-gradient(90deg,transparent,var(--neg),transparent)}
.kpi.t-warn::after{background:linear-gradient(90deg,transparent,var(--warn),transparent)}
.kpi.t-blue::after{background:linear-gradient(90deg,transparent,var(--blue),transparent)}
.kpi-lbl{
  font-family:'IBM Plex Mono',monospace;font-size:.58rem;font-weight:500;
  letter-spacing:.1em;text-transform:uppercase;color:var(--ink-mute);margin-bottom:.4rem;
}
.kpi-val{font-family:'IBM Plex Mono',monospace;font-size:1.55rem;font-weight:600;line-height:1.1}
.kpi-val.c-g{color:var(--pos)}.kpi-val.c-r{color:var(--neg)}.kpi-val.c-w{color:var(--warn)}
.kpi-note{
  font-family:'IBM Plex Mono',monospace;font-size:.62rem;color:var(--ink-mute);
  margin-top:.32rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
}
.pill{display:inline-block;padding:1px 5px;border-radius:3px;font-size:.57rem;font-weight:500;margin-left:2px}
.pill-g{background:var(--pos-dim);color:var(--pos)}
.pill-r{background:var(--neg-dim);color:var(--neg)}

/* ── PANELS ─────────────────────────────────────────────────────────── */
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:.8rem;margin-bottom:.8rem}
.grid1{display:grid;grid-template-columns:1fr;gap:.8rem;margin-bottom:.8rem}
.pnl{background:var(--s1);border:1px solid var(--edge);border-radius:var(--r);padding:1.05rem 1.2rem .85rem}
.chart-box{position:relative;width:100%;height:340px}
.pnl-hd{display:flex;align-items:center;justify-content:space-between;margin-bottom:.75rem;flex-wrap:wrap;gap:.4rem}
.pnl-t{font-family:'IBM Plex Mono',monospace;font-size:.65rem;font-weight:500;letter-spacing:.07em;text-transform:uppercase;color:var(--ink2)}
.dot{display:inline-block;width:5px;height:5px;border-radius:50%;margin-right:6px;vertical-align:middle}
.d-g{background:var(--pos);box-shadow:0 0 5px var(--pos-glow)}
.d-b{background:var(--blue);box-shadow:0 0 5px rgba(91,156,245,.25)}
.d-o{background:var(--orange);box-shadow:0 0 5px rgba(240,156,91,.25)}
.d-p{background:var(--purple);box-shadow:0 0 5px rgba(155,127,240,.25)}
.d-eq{background:var(--cyan,#22d3ee);box-shadow:0 0 5px rgba(34,211,238,.25)}
.d-ml{background:#a78bfa;box-shadow:0 0 5px rgba(167,139,250,.25)}
.ml-legend{display:flex;flex-wrap:wrap;gap:.35rem .7rem;font-family:'IBM Plex Mono',monospace;font-size:.58rem}
.ml-legend-item{display:flex;align-items:center;gap:4px;color:var(--ink2);cursor:pointer;transition:opacity .2s}
.ml-legend-item:hover{opacity:.7}
.ml-legend-swatch{width:10px;height:3px;border-radius:1px;flex-shrink:0}
.chart-box-wide{height:400px}
.eq-meta{
  font-family:'IBM Plex Mono',monospace;font-size:.62rem;color:var(--ink-mute);
  margin-top:.5rem;text-align:right;padding-right:.3rem;
}

/* ── TABLE ──────────────────────────────────────────────────────────── */
.tbl-box{background:var(--s1);border:1px solid var(--edge);border-radius:var(--r);padding:1.05rem 1.2rem;overflow-x:auto}
table.t{width:100%;border-collapse:collapse;font-family:'IBM Plex Mono',monospace;font-size:.7rem}
table.t th{
  text-align:left;font-weight:500;color:var(--ink-mute);letter-spacing:.06em;text-transform:uppercase;
  padding:.5rem .65rem;border-bottom:1px solid var(--edge-hi);font-size:.58rem;
  position:sticky;top:0;background:var(--s1);
}
table.t th:not(:first-child){text-align:right}
table.t td{padding:.45rem .65rem;border-bottom:1px solid var(--edge);color:var(--ink2);font-variant-numeric:tabular-nums}
table.t td:not(:first-child){text-align:right}
table.t td:first-child{color:var(--ink);font-weight:400;max-width:220px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
table.t tr:hover td{background:rgba(45,212,160,.02)}
table.t tr:last-child td{border-bottom:none}
.vp{color:var(--pos)}.vn{color:var(--neg)}
tr.tot td{border-top:2px solid var(--edge-hi);font-weight:600;color:var(--ink)!important;padding-top:.6rem}

/* ── RESPONSIVE ─────────────────────────────────────────────────────── */
@media(max-width:1024px){
  .grid2{grid-template-columns:1fr 1fr}
  .kpi-grid{grid-template-columns:repeat(auto-fit,minmax(170px,1fr))}
  .chart-box{height:300px}
  .chart-box-wide{height:360px}
  .wrap{padding:1.1rem 1.4rem 2.5rem}
}
@media(max-width:768px){
  .grid2{grid-template-columns:1fr}
  .kpi-grid{grid-template-columns:repeat(3,1fr)}
  .chart-box{height:280px}
  .chart-box-wide{height:320px}
  .wrap{padding:1rem}
  header{padding:1.1rem 1rem .85rem;flex-direction:column;align-items:flex-start}
  .hd-meta{text-align:left}
  html{font-size:14px}
  table.t{font-size:.67rem}
  table.t th{font-size:.56rem}
  .kpi-val{font-size:1.3rem}
  .pnl-t{font-size:.6rem}
}
@media(max-width:480px){
  .kpi-grid{grid-template-columns:1fr 1fr}
  .chart-box{height:220px}
  .chart-box-wide{height:260px}
  html{font-size:13px}
  .kpi{padding:.85rem .9rem}
  .kpi-val{font-size:1.1rem}
  .kpi-lbl{font-size:.53rem}
  .kpi-note{font-size:.55rem}
  .pnl{padding:.8rem .85rem .65rem}
  .pnl-t{font-size:.57rem}
  .tbl-box{padding:.8rem .85rem}
  table.t{font-size:.6rem}
  table.t th{font-size:.5rem}
  table.t td{padding:.35rem .4rem}
  table.t th{padding:.35rem .4rem}
  table.t td:first-child{max-width:120px}
  .hd-brand{font-size:1rem}
  .hd-brand em{font-size:.65rem}
  .hd-sub{font-size:.58rem}
  .wrap{padding:.7rem}
  header{padding:.85rem .7rem .65rem}
}
</style>
</head>
<body>

<!-- LOADING -->
<div id="loader">
  <div class="ld-brand">KORVEX</div>
  <div class="ld-ring"></div>
  <div class="ld-msg" id="ldMsg">Connecting to data source…</div>
</div>

<!-- ERROR -->
<div id="errBox"></div>

<!-- HEADER -->
<header>
  <div>
    <div class="hd-brand">KORVEX<em>SPORTS INTEL</em></div>
    <div class="hd-sub">NCAAB Spread Betting — Live Performance Dashboard</div>
  </div>
  <div class="hd-meta">
    <div class="live-dot">Auto-updating from Google Sheets</div>
    <div style="margin-top:2px">Refreshed: <b id="tsRefresh">—</b></div>
    <div id="metaWindow">—</div>
  </div>
</header>

<main class="wrap" id="main" style="display:none">
  <section class="kpi-grid" id="kpiRow"></section>

  <section class="grid1 anim" style="animation-delay:.08s">
    <div class="pnl" id="eqPanel">
      <div class="pnl-hd"><div class="pnl-t"><span class="dot d-eq"></span>Actual Bets — Equity Curve</div></div>
      <div class="chart-box chart-box-wide"><canvas id="cEquity"></canvas></div>
      <div id="eqMeta" class="eq-meta"></div>
    </div>
  </section>

  <section class="grid1 anim" style="animation-delay:.12s">
    <div class="pnl" id="mlPanel">
      <div class="pnl-hd">
        <div class="pnl-t"><span class="dot d-ml"></span>Cumulative PnL by Bucket</div>
        <div id="mlLegend" class="ml-legend"></div>
      </div>
      <div class="chart-box chart-box-wide"><canvas id="cMultiLine"></canvas></div>
      <div id="mlMeta" class="eq-meta"></div>
    </div>
  </section>

  <section class="grid2 anim" style="animation-delay:.16s">
    <div class="pnl">
      <div class="pnl-hd"><div class="pnl-t"><span class="dot d-g"></span>ROI by Bucket</div></div>
      <div class="chart-box"><canvas id="cRoiBar"></canvas></div>
    </div>
    <div class="pnl">
      <div class="pnl-hd"><div class="pnl-t"><span class="dot d-b"></span>Win % by Bucket</div></div>
      <div class="chart-box"><canvas id="cWpBar"></canvas></div>
    </div>
  </section>

  <section class="grid2 anim" style="animation-delay:.24s">
    <div class="pnl">
      <div class="pnl-hd"><div class="pnl-t"><span class="dot d-o"></span>Total Profit by Bucket</div></div>
      <div class="chart-box"><canvas id="cProfitBar"></canvas></div>
    </div>
    <div class="pnl">
      <div class="pnl-hd"><div class="pnl-t"><span class="dot d-p"></span>Cumulative Profit by Bucket</div></div>
      <div class="chart-box"><canvas id="cCumLine"></canvas></div>
    </div>
  </section>

  <section class="tbl-box anim" style="animation-delay:.32s">
    <div class="pnl-hd" style="margin-bottom:.55rem">
      <div class="pnl-t"><span class="dot d-g"></span>Bucket Performance Summary</div>
    </div>
    <table class="t"><thead><tr>
      <th>Bucket</th><th>W</th><th>L</th><th>Total</th><th>Win %</th><th>ROI</th><th>Profit</th>
    </tr></thead><tbody id="tblBody"></tbody></table>
  </section>
</main>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
/* ═══════════════════════════════════════════════════════════════════════════
   DATA SOURCE — Summary tab from Google Sheets
   ═══════════════════════════════════════════════════════════════════════════ */
const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT0Hwi4t6xp8RkR6Mih7sHpkk0dbvJ9bIuAl46givUktGiCQy6UXCb73BrgdC_UjeIndiNSi9WZUv4O/pub?gid=2059810443&single=true&output=csv";

const EQUITY_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSCjV2rud8IgNjheKVfRc-3RtSCA_IOWUfWP5gUBl5H2hPzf2rufKcAdLHexYtcJqtlx8Z37Vxe918z/pub?gid=1849141740&single=true&output=csv";

const MULTILINE_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSi04EMFZfH-dMRSXrnGz63K7E4QKseAgUInPlHacrUwXFBeyNw8DHJ4C-Wq9ewaXCsib5fg8VmjBhm/pub?gid=1948664093&single=true&output=csv";

const BREAK_EVEN = 52.38;

/* Chart.js global defaults */
Chart.defaults.color = "#6a6e84";
Chart.defaults.borderColor = "rgba(26,29,44,0.6)";
Chart.defaults.font.family = "'IBM Plex Mono','monospace'";
Chart.defaults.font.size = 10;
Chart.defaults.plugins.legend.display = false;
Chart.defaults.animation = { duration: 800, easing: "easeOutQuart" };
Chart.defaults.responsive = true;
Chart.defaults.maintainAspectRatio = false;

/* ═══════════════════════════════════════════════════════════════════════════
   CSV FETCH + PARSE via PapaParse
   ═══════════════════════════════════════════════════════════════════════════ */
async function fetchCSV(url) {
  /* Fallback chain: direct → corsproxy.io → allorigins → corsproxy.org */
  const strategies = [
    { name: "Direct",        url: url },
    { name: "corsproxy.io",  url: "https://corsproxy.io/?" + encodeURIComponent(url) },
    { name: "allorigins",    url: "https://api.allorigins.win/raw?url=" + encodeURIComponent(url) },
    { name: "corsproxy.org", url: "https://corsproxy.org/?" + encodeURIComponent(url) },
  ];

  const ldMsg = document.getElementById("ldMsg");
  let lastErr = null;

  for (const strat of strategies) {
    try {
      ldMsg.textContent = `Trying ${strat.name}…`;
      const r = await fetch(strat.url, { signal: AbortSignal.timeout(10000) });
      if (r.ok) return await r.text();
    } catch (e) { lastErr = e; }
  }

  throw new Error(
    "All fetch methods failed. Last error: " + (lastErr?.message || "Unknown") +
    "\n\nVerify the sheet is published: File → Share → Publish to web → CSV"
  );
}

/* ═══════════════════════════════════════════════════════════════════════════
   DATA PROCESSING — Read pre-computed summary from CSV
   ═══════════════════════════════════════════════════════════════════════════ */
function processCSV(csvText) {
  const parsed = Papa.parse(csvText, {
    header: false,
    skipEmptyLines: true,
    dynamicTyping: false
  });

  const rows = parsed.data;
  if (!rows || rows.length < 2) throw new Error("CSV appears empty.");

  /* Find the header row — look for "Description" or "Bucket" in first 20 rows */
  let hIdx = -1;
  for (let i = 0; i < Math.min(rows.length, 20); i++) {
    const lower = rows[i].map(c => (c || "").trim().toLowerCase());
    if (lower.includes("description") || lower.includes("bucket") || lower.includes("bucket name")) {
      hIdx = i;
      break;
    }
  }
  if (hIdx < 0) throw new Error("Could not find header row with 'Description' column. Found: " + rows[0].join(", "));

  /* Map column indices by fuzzy-matching header names */
  const hdr = rows[hIdx].map(c => (c || "").trim().toLowerCase());
  const col = (needles) => {
    for (const n of needles) {
      const idx = hdr.findIndex(h => h.includes(n));
      if (idx >= 0) return idx;
    }
    return -1;
  };

  const iDesc   = col(["description", "bucket name", "bucket"]);
  const iWins   = col(["wins", "win"]);
  const iLosses = col(["losses", "loss"]);
  const iTotal  = col(["total"]);
  const iWinPct = col(["% win", "win %", "win%", "winpct"]);
  const iROI    = col(["roi"]);
  const iProfit = col(["profit"]);

  if (iDesc < 0) throw new Error("Missing 'Description' column. Headers found: " + hdr.join(", "));

  /* Parse each data row */
  const summary = [];
  for (let r = hIdx + 1; r < rows.length; r++) {
    const row = rows[r];
    const name = (row[iDesc] || "").trim();
    if (!name) continue;

    /* Skip rows that look like totals — we compute our own */
    if (/^total$/i.test(name) || /^grand total$/i.test(name) || /^overall$/i.test(name)) continue;

    const parseNum = (idx) => {
      if (idx < 0 || idx >= row.length) return 0;
      let v = (row[idx] || "").trim();
      v = v.replace(/[$,%]/g, "").replace(/[()]/g, m => m === "(" ? "-" : "");
      const n = parseFloat(v);
      return isNaN(n) ? 0 : n;
    };

    const wins   = Math.round(parseNum(iWins));
    const losses = Math.round(parseNum(iLosses));
    const total  = iTotal >= 0 ? Math.round(parseNum(iTotal)) : wins + losses;
    const winPct = iWinPct >= 0 ? parseNum(iWinPct) : (total > 0 ? (wins / total) * 100 : 0);
    /* Normalize: if winPct looks like a fraction (0.567), convert to percentage */
    const winPctNorm = winPct > 0 && winPct < 1 ? winPct * 100 : winPct;
    const roi    = iROI >= 0 ? parseNum(iROI) : 0;
    const roiNorm = roi > 0 && roi < 1 ? roi * 100 : (roi < 0 && roi > -1 ? roi * 100 : roi);
    const profit = iProfit >= 0 ? parseNum(iProfit) : 0;

    summary.push({ name, wins, losses, total, winPct: winPctNorm, roi: roiNorm, profit });
  }

  if (summary.length === 0) throw new Error("No valid bucket rows found after header.");

  /* Compute dynamic totals */
  const totW = summary.reduce((a, s) => a + s.wins, 0);
  const totL = summary.reduce((a, s) => a + s.losses, 0);
  const totN = summary.reduce((a, s) => a + s.total, 0);
  const totWp = (totW + totL) > 0 ? (totW / (totW + totL)) * 100 : 0;
  const totProfit = summary.reduce((a, s) => a + s.profit, 0);
  const totRoi = (totW + totL) > 0 ? ((totW * 909.09 - totL * 1000) / ((totW + totL) * 1000)) * 100 : 0;

  const best  = summary.reduce((a, b) => (b.total >= 2 && b.roi > a.roi ? b : a), { roi: -Infinity, name: "—" });
  const worst = summary.reduce((a, b) => (b.total >= 2 && b.roi < a.roi ? b : a), { roi:  Infinity, name: "—" });

  return { summary, totW, totL, totN, totWp, totRoi, totProfit, best, worst };
}

/* ═══════════════════════════════════════════════════════════════════════════
   RENDERING
   ═══════════════════════════════════════════════════════════════════════════ */
function renderKPIs(stats) {
  const grid = document.getElementById("kpiRow");
  const cards = [
    { label: "Total Bets", value: stats.totN.toLocaleString(), cls: "t-blue", vcls: "" },
    { label: "Win %", value: stats.totWp.toFixed(1) + "%", cls: stats.totWp >= BREAK_EVEN ? "t-pos" : "t-neg", vcls: stats.totWp >= BREAK_EVEN ? "c-g" : "c-r" },
    { label: "ROI", value: (stats.totRoi >= 0 ? "+" : "") + stats.totRoi.toFixed(1) + "%", cls: stats.totRoi >= 0 ? "t-pos" : "t-neg", vcls: stats.totRoi >= 0 ? "c-g" : "c-r" },
    { label: "Total Profit", value: "$" + Math.round(stats.totProfit).toLocaleString(), cls: stats.totProfit >= 0 ? "t-pos" : "t-neg", vcls: stats.totProfit >= 0 ? "c-g" : "c-r",
      note: `${stats.totW}W – ${stats.totL}L` },
    { label: "Best ROI Bucket", value: (stats.best.roi >= 0 ? "+" : "") + stats.best.roi.toFixed(1) + "%", cls: "t-pos", vcls: "c-g",
      note: shortName(stats.best.name) },
    { label: "Worst ROI Bucket", value: stats.worst.roi.toFixed(1) + "%", cls: "t-neg", vcls: "c-r",
      note: shortName(stats.worst.name) }
  ];

  grid.innerHTML = cards.map((c, i) =>
    `<div class="kpi ${c.cls} anim" style="animation-delay:${i * .04}s">
       <div class="kpi-lbl">${c.label}</div>
       <div class="kpi-val ${c.vcls}">${c.value}</div>
       ${c.note ? `<div class="kpi-note">${c.note}</div>` : ""}
     </div>`
  ).join("");
}

function shortName(name) {
  return name.replace("(all spreads)", "(all)").replace("positive spread + negative ML", "+spd/−ML");
}

function renderTable(stats) {
  const body = document.getElementById("tblBody");
  let html = stats.summary.map(s => {
    const wpCls = s.winPct >= BREAK_EVEN ? "vp" : "vn";
    const roiCls = s.roi >= 0 ? "vp" : "vn";
    const prCls = s.profit >= 0 ? "vp" : "vn";
    return `<tr>
      <td title="${s.name}">${s.name}</td>
      <td>${s.wins}</td><td>${s.losses}</td><td>${s.total}</td>
      <td class="${wpCls}">${s.winPct.toFixed(1)}%</td>
      <td class="${roiCls}">${s.roi >= 0 ? "+" : ""}${s.roi.toFixed(1)}%</td>
      <td class="${prCls}">$${Math.round(s.profit).toLocaleString()}</td>
    </tr>`;
  }).join("");

  /* Dynamic TOTAL row */
  const twcls = stats.totWp >= BREAK_EVEN ? "vp" : "vn";
  const trcls = stats.totRoi >= 0 ? "vp" : "vn";
  const tpcls = stats.totProfit >= 0 ? "vp" : "vn";
  html += `<tr class="tot">
    <td>TOTAL</td>
    <td>${stats.totW}</td><td>${stats.totL}</td><td>${stats.totN}</td>
    <td class="${twcls}">${stats.totWp.toFixed(1)}%</td>
    <td class="${trcls}">${stats.totRoi >= 0 ? "+" : ""}${stats.totRoi.toFixed(1)}%</td>
    <td class="${tpcls}">$${Math.round(stats.totProfit).toLocaleString()}</td>
  </tr>`;
  body.innerHTML = html;
}

/* ── CHART HELPERS ─────────────────────────────────────────────────── */
const C = {
  pos: "#2dd4a0", posBg: "rgba(45,212,160,0.65)",
  neg: "#f4718a", negBg: "rgba(244,113,138,0.65)",
  blue: "#5b9cf5", blueBg: "rgba(91,156,245,0.65)",
  orange: "#f09c5b", orangeBg: "rgba(240,156,91,0.65)",
  purple: "#9b7ff0", purpleBg: "rgba(155,127,240,0.65)",
  grid: "rgba(26,29,44,0.8)",
  gridLight: "rgba(40,43,62,0.5)"
};

function barColors(vals, posC, negC) { return vals.map(v => v >= 0 ? posC : negC); }

function shortLabel(name) {
  return name
    .replace(/Fav -(\d+) to -(\d+) × ([\d.-]+) spread/,  "F −$1/−$2")
    .replace(/Fav -(\d+)\+ \(all spreads\)/,               "F −$1+")
    .replace(/Fav -(\d+) to -(\d+) \(all spreads\)/,       "F −$1/−$2")
    .replace(/Dog \+(\d+)-(\d+) × ([\d.-]+) spreads?/,     "D +$1/$3")
    .replace(/Dog \+(\d+)-(\d+) × ([\d.-]+)-([\d.]+)/,     "D +$1/$3–$4")
    .replace(/Dog \+(\d+)-(\d+) \(all spreads\)/,           "D +$1/+$2")
    .replace(/Dog \+(\d+)\+ \(all spreads\)/,               "D +$1+")
    .replace(/Gap games.*/, "Gap")
    .replace("Fav Other", "F Other")
    .replace("Dog Other", "D Other");
}

function makeScales(yLabel, pct) {
  return {
    x: {
      grid: { color: C.grid, drawBorder: false },
      ticks: { maxRotation: 55, minRotation: 35, font: { size: 9 } }
    },
    y: {
      grid: { color: C.gridLight, drawBorder: false },
      ticks: { callback: v => pct ? v.toFixed(0) + "%" : "$" + v.toLocaleString(), font: { size: 9 } },
      title: { display: true, text: yLabel, color: "#6a6e84", font: { size: 10 } }
    }
  };
}

/* ── RENDER CHARTS ──────────────────────────────────────────────────── */
function renderCharts(stats) {
  const labels = stats.summary.map(s => shortLabel(s.name));
  const roiVals = stats.summary.map(s => +s.roi.toFixed(2));
  const wpVals = stats.summary.map(s => +s.winPct.toFixed(2));
  const profitVals = stats.summary.map(s => Math.round(s.profit));

  /* Cumulative profit across buckets (sorted by name order) */
  let running = 0;
  const cumVals = stats.summary.map(s => { running += s.profit; return Math.round(running); });

  /* ── ROI BAR ── */
  new Chart(document.getElementById("cRoiBar"), {
    type: "bar",
    data: { labels, datasets: [{
      data: roiVals,
      backgroundColor: barColors(roiVals, C.posBg, C.negBg),
      borderColor: barColors(roiVals, C.pos, C.neg),
      borderWidth: 1, borderRadius: 3, maxBarThickness: 38
    }]},
    options: {
      scales: makeScales("ROI %", true),
      plugins: {
        tooltip: { callbacks: {
          title: (items) => stats.summary[items[0].dataIndex].name,
          label: (item) => "ROI: " + (item.raw >= 0 ? "+" : "") + item.raw.toFixed(1) + "%"
        }},
        annotation: { annotations: {
          zero: { type: "line", yMin: 0, yMax: 0, borderColor: "rgba(255,255,255,0.12)", borderWidth: 1, borderDash: [4, 4] }
        }}
      }
    }
  });

  /* ── WIN % BAR ── */
  new Chart(document.getElementById("cWpBar"), {
    type: "bar",
    data: { labels, datasets: [{
      data: wpVals,
      backgroundColor: wpVals.map(v => v >= BREAK_EVEN ? C.blueBg : C.negBg),
      borderColor: wpVals.map(v => v >= BREAK_EVEN ? C.blue : C.neg),
      borderWidth: 1, borderRadius: 3, maxBarThickness: 38
    }]},
    options: {
      scales: makeScales("Win %", true),
      plugins: {
        tooltip: { callbacks: {
          title: (items) => stats.summary[items[0].dataIndex].name,
          label: (item) => "Win %: " + item.raw.toFixed(1) + "%"
        }},
        annotation: { annotations: {
          breakeven: {
            type: "line", yMin: BREAK_EVEN, yMax: BREAK_EVEN,
            borderColor: "rgba(245,197,66,0.5)", borderWidth: 1.5, borderDash: [6, 3],
            label: { display: true, content: "Break-even 52.38%", position: "start",
              backgroundColor: "rgba(245,197,66,0.12)", color: "#f5c542",
              font: { size: 9, family: "'IBM Plex Mono'" }, padding: 3
            }
          }
        }}
      }
    }
  });

  /* ── PROFIT BAR ── */
  new Chart(document.getElementById("cProfitBar"), {
    type: "bar",
    data: { labels, datasets: [{
      data: profitVals,
      backgroundColor: barColors(profitVals, C.orangeBg, C.negBg),
      borderColor: barColors(profitVals, C.orange, C.neg),
      borderWidth: 1, borderRadius: 3, maxBarThickness: 38
    }]},
    options: {
      scales: makeScales("Profit ($)", false),
      plugins: {
        tooltip: { callbacks: {
          title: (items) => stats.summary[items[0].dataIndex].name,
          label: (item) => "Profit: $" + item.raw.toLocaleString()
        }},
        annotation: { annotations: {
          zero: { type: "line", yMin: 0, yMax: 0, borderColor: "rgba(255,255,255,0.12)", borderWidth: 1, borderDash: [4, 4] }
        }}
      }
    }
  });

  /* ── CUMULATIVE PROFIT LINE ── */
  new Chart(document.getElementById("cCumLine"), {
    type: "line",
    data: { labels, datasets: [{
      data: cumVals,
      borderColor: C.purple,
      backgroundColor: C.purpleBg.replace("0.65", "0.08"),
      fill: true, tension: 0.3, pointRadius: 3,
      pointBackgroundColor: C.purple, pointBorderColor: "transparent", borderWidth: 2
    }]},
    options: {
      scales: {
        x: { grid: { color: C.grid, drawBorder: false }, ticks: { maxRotation: 55, minRotation: 35, font: { size: 9 } } },
        y: { grid: { color: C.gridLight, drawBorder: false },
          ticks: { callback: v => "$" + v.toLocaleString(), font: { size: 9 } },
          title: { display: true, text: "Cumulative Profit ($)", color: "#6a6e84", font: { size: 10 } }
        }
      },
      plugins: {
        tooltip: { callbacks: {
          title: (items) => stats.summary[items[0].dataIndex].name,
          label: (item) => "Cumulative: $" + item.raw.toLocaleString()
        }},
        annotation: { annotations: {
          zero: { type: "line", yMin: 0, yMax: 0, borderColor: "rgba(255,255,255,0.1)", borderWidth: 1, borderDash: [4, 4] }
        }}
      }
    }
  });
}

/* ═══════════════════════════════════════════════════════════════════════════
   META
   ═══════════════════════════════════════════════════════════════════════════ */
function renderMeta(stats) {
  document.getElementById("tsRefresh").textContent =
    new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  document.getElementById("metaWindow").innerHTML =
    `${stats.summary.length} buckets · <b>${stats.totN}</b> total bets · $1k flat @ −110`;
}

/* ═══════════════════════════════════════════════════════════════════════════
   EQUITY CURVE — Parse bet-level CSV and render cumulative profit line
   ═══════════════════════════════════════════════════════════════════════════
   
   FIX: Now computes cumulative PnL from per-bet profit column instead of
   relying on a pre-computed Cumulative PNL column. This prevents stale data
   from Google Sheets publish cache and removes the need to drag formulas
   down when adding new rows.
   
   Strategy:
   1. Find the "profit" column (per-bet profit/loss)
   2. Find the "result" column to filter out pending bets (no result yet)
   3. Compute running cumulative sum in JavaScript
   4. Fall back to pre-computed "Cumulative PNL" column if profit column missing
   ═══════════════════════════════════════════════════════════════════════════ */
function parseEquityCSV(csvText) {
  const parsed = Papa.parse(csvText, { header: false, skipEmptyLines: true, dynamicTyping: false });
  const rows = parsed.data;
  if (!rows || rows.length < 2) throw new Error("Equity CSV appears empty (" + (rows ? rows.length : 0) + " rows).");

  /* Find header row — look for "date" in first 30 rows */
  let hIdx = -1;
  for (let i = 0; i < Math.min(rows.length, 30); i++) {
    const lower = rows[i].map(c => (c || "").trim().toLowerCase());
    if (lower.some(h => h === "date" || h === "dates")) { hIdx = i; break; }
  }
  if (hIdx < 0) throw new Error("Equity CSV: no header row with 'Date'. Row 0: [" + (rows[0] || []).slice(0, 8).join(", ") + "]");

  const hdr = rows[hIdx].map(c => (c || "").trim().toLowerCase());
  const iDate = hdr.findIndex(h => h === "date" || h === "dates");

  /* ── Column detection ──────────────────────────────────────────────
     Primary: use per-bet "profit" column + compute cumulative in JS
     Fallback: use pre-computed "Cumulative PNL" column if profit missing
     ──────────────────────────────────────────────────────────────────── */
  
  /* Find per-bet profit column */
  const iProfit = hdr.findIndex(h => h === "profit");
  
  /* Find result column to filter pending bets */
  const iResult = hdr.findIndex(h => h === "result");
  
  /* Find odds and wager columns for self-computed profit as extra fallback */
  const iOdds = hdr.findIndex(h => h === "odds");
  const iWager = hdr.findIndex(h => h === "wager");

  /* Fallback: pre-computed cumulative column */
  let iCum = -1;
  iCum = hdr.findIndex(h => h.includes("cumulative") || h.includes("cum "));
  if (iCum < 0) iCum = hdr.findIndex(h => h.includes("running") || h.includes("equity"));

  /* Determine which strategy to use */
  const useProfit = iProfit >= 0;
  const useCum = !useProfit && iCum >= 0;
  
  /* Last resort: find the last numeric column */
  if (!useProfit && !useCum && rows.length > hIdx + 1) {
    const testRow = rows[hIdx + 1];
    if (testRow) {
      for (let c = testRow.length - 1; c >= 0; c--) {
        const v = (testRow[c] || "").trim().replace(/[$,]/g, "");
        if (v && !isNaN(parseFloat(v)) && Math.abs(parseFloat(v)) > 10) { iCum = c; break; }
      }
    }
  }

  if (!useProfit && iCum < 0) {
    throw new Error("Equity CSV: could not find 'profit' or 'Cumulative PNL' column. Headers: [" + hdr.join(", ") + "]");
  }

  console.log(`Equity CSV: strategy=${useProfit ? 'COMPUTE from profit col ' + iProfit : 'READ cumulative col ' + iCum}, result col=${iResult}, Date col=${iDate}, header at row ${hIdx}, ${rows.length - hIdx - 1} data rows`);

  /* ── Helper to parse a numeric cell ────────────────────────────────── */
  function parseCell(val) {
    let v = (val || "").trim();
    if (!v) return NaN;
    v = v.replace(/[$,]/g, "").replace(/^\((.+)\)$/, "-$1");
    return parseFloat(v);
  }

  /* ── Parse data rows ───────────────────────────────────────────────── */
  const points = [];
  let skipped = 0;
  let cumulative = 0;

  for (let r = hIdx + 1; r < rows.length; r++) {
    const row = rows[r];
    if (!row || row.length <= iDate) { skipped++; continue; }

    const dateStr = (row[iDate] || "").trim();
    if (!dateStr) { skipped++; continue; }

    /* Parse date — handle M/D/YY, M/D/YYYY, YYYY-MM-DD */
    let d;
    if (/^\d{4}-\d{2}-\d{2}/.test(dateStr)) {
      d = new Date(dateStr.split(" ")[0] + "T12:00:00");
    } else if (/^\d{1,2}\/\d{1,2}\/\d{2,4}/.test(dateStr)) {
      const parts = dateStr.split("/");
      const y = parts[2] && parts[2].length <= 2 ? 2000 + parseInt(parts[2]) : parseInt(parts[2]);
      d = new Date(y, parseInt(parts[0]) - 1, parseInt(parts[1]));
    } else {
      d = new Date(dateStr);
    }
    if (!d || isNaN(d.getTime())) { skipped++; continue; }

    /* ── Strategy A: Compute cumulative from per-bet profit ────────── */
    if (useProfit) {
      /* Skip rows with no result (pending bets) */
      if (iResult >= 0) {
        const result = (row[iResult] || "").trim().toUpperCase();
        if (result !== "W" && result !== "L") { skipped++; continue; }
      }

      const profit = parseCell(row[iProfit]);
      
      /* If profit column is empty but we have odds + wager + result, compute it */
      if (isNaN(profit) && iOdds >= 0 && iWager >= 0 && iResult >= 0) {
        const odds = parseCell(row[iOdds]);
        const wager = parseCell(row[iWager]);
        const result = (row[iResult] || "").trim().toUpperCase();
        if (!isNaN(odds) && !isNaN(wager) && (result === "W" || result === "L")) {
          let betProfit;
          if (result === "W") {
            betProfit = odds > 0 ? wager * (odds / 100) : wager * (100 / Math.abs(odds));
          } else {
            betProfit = -wager;
          }
          cumulative += betProfit;
        } else {
          skipped++;
          continue;
        }
      } else if (isNaN(profit)) {
        skipped++;
        continue;
      } else {
        cumulative += profit;
      }

      points.push({
        date: d,
        label: d.toLocaleDateString("en-US", { month: "short", day: "numeric" }),
        profit: Math.round(cumulative * 100) / 100
      });
    }
    /* ── Strategy B: Read pre-computed cumulative column ───────────── */
    else {
      let v = (row[iCum] || "").trim();
      if (!v) { skipped++; continue; }
      const val = parseCell(v);
      if (isNaN(val)) { skipped++; continue; }

      points.push({
        date: d,
        label: d.toLocaleDateString("en-US", { month: "short", day: "numeric" }),
        profit: val
      });
    }
  }

  console.log("Equity CSV: " + points.length + " valid points, " + skipped + " skipped" + (useProfit ? ", computed cumulative from profit column" : ""));

  if (points.length === 0) {
    const sample = rows[hIdx + 1] || [];
    throw new Error("0 valid points. Headers: [" + hdr.join(", ") + "]. First data row: [" + sample.slice(0, 8).join(" | ") + "]");
  }

  /* Sort chronologically */
  points.sort((a, b) => a.date - b.date);
  return points;
}

function renderEquityCurve(points) {
  if (points.length === 0) return;

  const labels = points.map(p => p.label);
  const data = points.map(p => Math.round(p.profit));
  const peak = Math.max(...data);
  const current = data[data.length - 1];

  /* Gradient fill — cyan glow */
  const ctx = document.getElementById("cEquity").getContext("2d");
  const grad = ctx.createLinearGradient(0, 0, 0, 400);
  grad.addColorStop(0, "rgba(34,211,238,0.15)");
  grad.addColorStop(0.5, "rgba(34,211,238,0.04)");
  grad.addColorStop(1, "rgba(34,211,238,0)");

  new Chart(ctx, {
    type: "line",
    data: { labels, datasets: [{
      data,
      borderColor: "#22d3ee",
      backgroundColor: grad,
      fill: true,
      tension: 0.35,
      pointRadius: 0,
      pointHitRadius: 8,
      pointHoverRadius: 4,
      pointHoverBackgroundColor: "#22d3ee",
      pointHoverBorderColor: "#0a0b12",
      pointHoverBorderWidth: 2,
      borderWidth: 2.2
    }]},
    options: {
      interaction: { mode: "index", intersect: false },
      scales: {
        x: {
          grid: { color: C.grid, drawBorder: false },
          ticks: { maxRotation: 40, font: { size: 9 }, maxTicksLimit: 20, autoSkip: true }
        },
        y: {
          grid: { color: C.gridLight, drawBorder: false },
          ticks: { callback: v => "$" + v.toLocaleString(), font: { size: 9 } },
          title: { display: true, text: "Cumulative Profit ($)", color: "#6a6e84", font: { size: 10 } }
        }
      },
      plugins: {
        tooltip: {
          backgroundColor: "rgba(15,16,25,0.95)",
          borderColor: "rgba(34,211,238,0.3)",
          borderWidth: 1,
          titleFont: { family: "'IBM Plex Mono'" },
          bodyFont: { family: "'IBM Plex Mono'" },
          callbacks: { label: (item) => "P&L: $" + item.raw.toLocaleString() }
        },
        annotation: { annotations: {
          zero: { type: "line", yMin: 0, yMax: 0, borderColor: "rgba(255,255,255,0.08)", borderWidth: 1, borderDash: [4, 4] }
        }}
      }
    }
  });

  /* Meta line under chart */
  const fmt = d => d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
  document.getElementById("eqMeta").innerHTML =
    `${points.length} data points · ${fmt(points[0].date)} – ${fmt(points[points.length - 1].date)} · ` +
    `Peak: <span style="color:var(--pos)">$${peak.toLocaleString()}</span> · ` +
    `Current: <span style="color:${current >= 0 ? 'var(--pos)' : 'var(--neg)'}">$${current.toLocaleString()}</span>`;
}

/* ═══════════════════════════════════════════════════════════════════════════
   MULTI-LINE PNL — Parse bucket-level cumulative PnL and render overlay
   ═══════════════════════════════════════════════════════════════════════════ */
const ML_COLORS = [
  "#2dd4a0","#5b9cf5","#f09c5b","#f4718a","#a78bfa",
  "#22d3ee","#f5c542","#ec4899","#6ee7b7","#818cf8",
  "#fb923c","#38bdf8","#c084fc","#f87171","#34d399",
  "#fbbf24","#a3e635","#e879f9","#67e8f9","#fca5a5"
];

function parseMultiLineCSV(csvText) {
  const parsed = Papa.parse(csvText, { header: false, skipEmptyLines: true, dynamicTyping: false });
  const rows = parsed.data;
  if (!rows || rows.length < 2) throw new Error("Multi-line CSV appears empty.");

  /* Find header row — first row that has "date" in column 0 or 1 */
  let hIdx = -1;
  for (let i = 0; i < Math.min(rows.length, 15); i++) {
    const first = (rows[i][0] || "").trim().toLowerCase();
    if (first === "date" || first === "dates" || first === "day") { hIdx = i; break; }
  }
  if (hIdx < 0) throw new Error("Multi-line CSV: no header row starting with 'Date'. Row 0: " + (rows[0] || []).slice(0, 5).join(", "));

  const hdr = rows[hIdx].map(c => (c || "").trim());
  const bucketNames = hdr.slice(1).filter(h => h.length > 0);

  if (bucketNames.length === 0) throw new Error("Multi-line CSV: no bucket columns found after Date. Headers: " + hdr.join(", "));

  /* Parse data rows */
  const dates = [];
  const series = {}; // bucketName → [values]
  bucketNames.forEach(b => { series[b] = []; });

  for (let r = hIdx + 1; r < rows.length; r++) {
    const row = rows[r];
    const dateStr = (row[0] || "").trim();
    if (!dateStr) continue;

    /* Parse date */
    let d;
    if (/^\d{4}-\d{2}-\d{2}/.test(dateStr)) {
      d = new Date(dateStr.split(" ")[0] + "T12:00:00");
    } else if (/^\d{1,2}\/\d{1,2}\/\d{2,4}/.test(dateStr)) {
      const p = dateStr.split("/");
      const y = p[2] && p[2].length <= 2 ? 2000 + parseInt(p[2]) : parseInt(p[2]);
      d = new Date(y, parseInt(p[0]) - 1, parseInt(p[1]));
    } else {
      d = new Date(dateStr);
    }
    if (!d || isNaN(d.getTime())) continue;

    dates.push(d.toLocaleDateString("en-US", { month: "short", day: "numeric" }));

    bucketNames.forEach((name, i) => {
      const raw = (row[i + 1] || "").trim().replace(/[$,]/g, "").replace(/^\((.+)\)$/, "-$1");
      const val = parseFloat(raw);
      series[name].push(isNaN(val) ? null : val);
    });
  }

  if (dates.length === 0) throw new Error("Multi-line CSV: 0 valid date rows parsed.");

  console.log("Multi-line CSV: " + dates.length + " dates, " + bucketNames.length + " buckets: " + bucketNames.join(", "));
  return { dates, bucketNames, series };
}

function renderMultiLineChart(data) {
  const { dates, bucketNames, series } = data;

  /* Build datasets */
  const datasets = bucketNames.map((name, i) => {
    const color = ML_COLORS[i % ML_COLORS.length];
    return {
      label: name,
      data: series[name],
      borderColor: color,
      backgroundColor: "transparent",
      borderWidth: 2,
      tension: 0.35,
      pointRadius: 0,
      pointHitRadius: 8,
      pointHoverRadius: 4,
      pointHoverBackgroundColor: color,
      pointHoverBorderColor: "#0a0b12",
      pointHoverBorderWidth: 2,
      spanGaps: true
    };
  });

  /* Custom legend */
  const legendEl = document.getElementById("mlLegend");
  legendEl.innerHTML = bucketNames.map((name, i) => {
    const color = ML_COLORS[i % ML_COLORS.length];
    return `<span class="ml-legend-item" data-idx="${i}">
      <span class="ml-legend-swatch" style="background:${color}"></span>${name}
    </span>`;
  }).join("");

  const chart = new Chart(document.getElementById("cMultiLine"), {
    type: "line",
    data: { labels: dates, datasets },
    options: {
      interaction: { mode: "index", intersect: false },
      scales: {
        x: {
          grid: { color: C.grid, drawBorder: false },
          ticks: { maxRotation: 40, font: { size: 9 }, maxTicksLimit: 20, autoSkip: true }
        },
        y: {
          grid: { color: C.gridLight, drawBorder: false },
          ticks: { callback: v => "$" + v.toLocaleString(), font: { size: 9 } },
          title: { display: true, text: "Cumulative PnL ($)", color: "#6a6e84", font: { size: 10 } }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: "rgba(15,16,25,0.95)",
          borderColor: "rgba(167,139,250,0.3)",
          borderWidth: 1,
          titleFont: { family: "'IBM Plex Mono'", size: 11 },
          bodyFont: { family: "'IBM Plex Mono'", size: 10 },
          callbacks: {
            label: (item) => {
              const v = item.raw;
              if (v === null || v === undefined) return null;
              return " " + item.dataset.label + ": $" + v.toLocaleString();
            }
          }
        },
        annotation: { annotations: {
          zero: { type: "line", yMin: 0, yMax: 0, borderColor: "rgba(255,255,255,0.08)", borderWidth: 1, borderDash: [4, 4] }
        }}
      }
    }
  });

  /* Click legend items to toggle visibility */
  legendEl.addEventListener("click", (e) => {
    const item = e.target.closest(".ml-legend-item");
    if (!item) return;
    const idx = parseInt(item.dataset.idx);
    const meta = chart.getDatasetMeta(idx);
    meta.hidden = !meta.hidden;
    item.style.opacity = meta.hidden ? "0.3" : "1";
    chart.update();
  });

  /* Meta */
  const lastVals = bucketNames.map(name => {
    const arr = series[name].filter(v => v !== null);
    return arr.length > 0 ? arr[arr.length - 1] : 0;
  });
  const best = bucketNames[lastVals.indexOf(Math.max(...lastVals))];
  const worst = bucketNames[lastVals.indexOf(Math.min(...lastVals))];
  document.getElementById("mlMeta").innerHTML =
    `${bucketNames.length} buckets · ${dates.length} dates · ` +
    `Best: <span style="color:var(--pos)">${best}</span> · ` +
    `Worst: <span style="color:var(--neg)">${worst}</span> · ` +
    `Click legend to toggle`;
}

/* ═══════════════════════════════════════════════════════════════════════════
   BOOT
   ═══════════════════════════════════════════════════════════════════════════ */
async function boot() {
  const loader = document.getElementById("loader");
  const ldMsg  = document.getElementById("ldMsg");
  const errBox = document.getElementById("errBox");

  try {
    ldMsg.textContent = "Fetching live data from Google Sheets…";

    /* Fetch all 3 CSVs in parallel */
    const [summaryText, equityText, multiLineText] = await Promise.all([
      fetchCSV(SHEET_URL),
      fetchCSV(EQUITY_CSV_URL).catch(e => { console.warn("Equity CSV fetch failed:", e); return null; }),
      fetchCSV(MULTILINE_CSV_URL).catch(e => { console.warn("Multi-line CSV fetch failed:", e); return null; })
    ]);

    ldMsg.textContent = "Parsing with PapaParse…";
    const stats = processCSV(summaryText);

    let equityPoints = [];
    let equityError = null;
    if (equityText) {
      try { equityPoints = parseEquityCSV(equityText); }
      catch (e) { equityError = e; console.warn("Equity CSV parse error:", e); }
    } else {
      equityError = new Error("Fetch returned empty — CSV may not be published");
    }

    ldMsg.textContent = "Rendering dashboard…";
    await new Promise(r => setTimeout(r, 80));

    document.getElementById("main").style.display = "block";
    renderKPIs(stats);
    renderTable(stats);
    renderCharts(stats);
    renderMeta(stats);

    if (equityPoints.length > 0) {
      renderEquityCurve(equityPoints);
    } else {
      document.getElementById("eqMeta").innerHTML =
        '<span style="color:var(--warn)">⚠ Equity curve: ' +
        (equityError ? equityError.message : 'No data points found') +
        '</span>';
    }

    /* Multi-line bucket PnL chart */
    if (multiLineText) {
      try {
        const mlData = parseMultiLineCSV(multiLineText);
        renderMultiLineChart(mlData);
      } catch (e) {
        console.warn("Multi-line PnL error:", e);
        document.getElementById("mlMeta").innerHTML =
          '<span style="color:var(--warn)">⚠ Bucket PnL: ' + e.message + '</span>';
      }
    } else {
      document.getElementById("mlMeta").innerHTML =
        '<span style="color:var(--warn)">⚠ Bucket PnL CSV unavailable — check published link</span>';
    }

    loader.classList.add("done");
  } catch (err) {
    loader.classList.add("done");
    errBox.style.display = "block";
    errBox.innerHTML = `<strong>Data Error</strong><br>${err.message}<br><br>
      <span style="color:var(--ink3)">Make sure your Google Sheet is published to the web as CSV and the URL is correct.
      <br>Google Sheets → File → Share → Publish to web → select the correct tab → CSV → Publish</span>`;
    console.error(err);
  }
}

boot();
</script>
</body>
</html>
